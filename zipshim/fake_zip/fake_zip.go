// Code generated by counterfeiter. DO NOT EDIT.
package fake_zip

import (
	"archive/zip"
	"io"
	"os"
	"sync"

	goshim "github.com/daniellavoie/go-shim"
)

type FakeZip struct {
	OpenReaderStub        func(name string) (*zip.ReadCloser, error)
	openReaderMutex       sync.RWMutex
	openReaderArgsForCall []struct {
		name string
	}
	openReaderReturns struct {
		result1 *zip.ReadCloser
		result2 error
	}
	openReaderReturnsOnCall map[int]struct {
		result1 *zip.ReadCloser
		result2 error
	}
	NewReaderStub        func(r io.ReaderAt, size int64) (*zip.Reader, error)
	newReaderMutex       sync.RWMutex
	newReaderArgsForCall []struct {
		r    io.ReaderAt
		size int64
	}
	newReaderReturns struct {
		result1 *zip.Reader
		result2 error
	}
	newReaderReturnsOnCall map[int]struct {
		result1 *zip.Reader
		result2 error
	}
	RegisterDecompressorStub        func(method uint16, dcomp zip.Decompressor)
	registerDecompressorMutex       sync.RWMutex
	registerDecompressorArgsForCall []struct {
		method uint16
		dcomp  zip.Decompressor
	}
	RegisterCompressorStub        func(method uint16, comp zip.Compressor)
	registerCompressorMutex       sync.RWMutex
	registerCompressorArgsForCall []struct {
		method uint16
		comp   zip.Compressor
	}
	FileInfoHeaderStub        func(fi os.FileInfo) (*zip.FileHeader, error)
	fileInfoHeaderMutex       sync.RWMutex
	fileInfoHeaderArgsForCall []struct {
		fi os.FileInfo
	}
	fileInfoHeaderReturns struct {
		result1 *zip.FileHeader
		result2 error
	}
	fileInfoHeaderReturnsOnCall map[int]struct {
		result1 *zip.FileHeader
		result2 error
	}
	NewWriterStub        func(w io.Writer) *zip.Writer
	newWriterMutex       sync.RWMutex
	newWriterArgsForCall []struct {
		w io.Writer
	}
	newWriterReturns struct {
		result1 *zip.Writer
	}
	newWriterReturnsOnCall map[int]struct {
		result1 *zip.Writer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeZip) OpenReader(name string) (*zip.ReadCloser, error) {
	fake.openReaderMutex.Lock()
	ret, specificReturn := fake.openReaderReturnsOnCall[len(fake.openReaderArgsForCall)]
	fake.openReaderArgsForCall = append(fake.openReaderArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("OpenReader", []interface{}{name})
	fake.openReaderMutex.Unlock()
	if fake.OpenReaderStub != nil {
		return fake.OpenReaderStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.openReaderReturns.result1, fake.openReaderReturns.result2
}

func (fake *FakeZip) OpenReaderCallCount() int {
	fake.openReaderMutex.RLock()
	defer fake.openReaderMutex.RUnlock()
	return len(fake.openReaderArgsForCall)
}

func (fake *FakeZip) OpenReaderArgsForCall(i int) string {
	fake.openReaderMutex.RLock()
	defer fake.openReaderMutex.RUnlock()
	return fake.openReaderArgsForCall[i].name
}

func (fake *FakeZip) OpenReaderReturns(result1 *zip.ReadCloser, result2 error) {
	fake.OpenReaderStub = nil
	fake.openReaderReturns = struct {
		result1 *zip.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) OpenReaderReturnsOnCall(i int, result1 *zip.ReadCloser, result2 error) {
	fake.OpenReaderStub = nil
	if fake.openReaderReturnsOnCall == nil {
		fake.openReaderReturnsOnCall = make(map[int]struct {
			result1 *zip.ReadCloser
			result2 error
		})
	}
	fake.openReaderReturnsOnCall[i] = struct {
		result1 *zip.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) NewReader(r io.ReaderAt, size int64) (*zip.Reader, error) {
	fake.newReaderMutex.Lock()
	ret, specificReturn := fake.newReaderReturnsOnCall[len(fake.newReaderArgsForCall)]
	fake.newReaderArgsForCall = append(fake.newReaderArgsForCall, struct {
		r    io.ReaderAt
		size int64
	}{r, size})
	fake.recordInvocation("NewReader", []interface{}{r, size})
	fake.newReaderMutex.Unlock()
	if fake.NewReaderStub != nil {
		return fake.NewReaderStub(r, size)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.newReaderReturns.result1, fake.newReaderReturns.result2
}

func (fake *FakeZip) NewReaderCallCount() int {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return len(fake.newReaderArgsForCall)
}

func (fake *FakeZip) NewReaderArgsForCall(i int) (io.ReaderAt, int64) {
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	return fake.newReaderArgsForCall[i].r, fake.newReaderArgsForCall[i].size
}

func (fake *FakeZip) NewReaderReturns(result1 *zip.Reader, result2 error) {
	fake.NewReaderStub = nil
	fake.newReaderReturns = struct {
		result1 *zip.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) NewReaderReturnsOnCall(i int, result1 *zip.Reader, result2 error) {
	fake.NewReaderStub = nil
	if fake.newReaderReturnsOnCall == nil {
		fake.newReaderReturnsOnCall = make(map[int]struct {
			result1 *zip.Reader
			result2 error
		})
	}
	fake.newReaderReturnsOnCall[i] = struct {
		result1 *zip.Reader
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) RegisterDecompressor(method uint16, dcomp zip.Decompressor) {
	fake.registerDecompressorMutex.Lock()
	fake.registerDecompressorArgsForCall = append(fake.registerDecompressorArgsForCall, struct {
		method uint16
		dcomp  zip.Decompressor
	}{method, dcomp})
	fake.recordInvocation("RegisterDecompressor", []interface{}{method, dcomp})
	fake.registerDecompressorMutex.Unlock()
	if fake.RegisterDecompressorStub != nil {
		fake.RegisterDecompressorStub(method, dcomp)
	}
}

func (fake *FakeZip) RegisterDecompressorCallCount() int {
	fake.registerDecompressorMutex.RLock()
	defer fake.registerDecompressorMutex.RUnlock()
	return len(fake.registerDecompressorArgsForCall)
}

func (fake *FakeZip) RegisterDecompressorArgsForCall(i int) (uint16, zip.Decompressor) {
	fake.registerDecompressorMutex.RLock()
	defer fake.registerDecompressorMutex.RUnlock()
	return fake.registerDecompressorArgsForCall[i].method, fake.registerDecompressorArgsForCall[i].dcomp
}

func (fake *FakeZip) RegisterCompressor(method uint16, comp zip.Compressor) {
	fake.registerCompressorMutex.Lock()
	fake.registerCompressorArgsForCall = append(fake.registerCompressorArgsForCall, struct {
		method uint16
		comp   zip.Compressor
	}{method, comp})
	fake.recordInvocation("RegisterCompressor", []interface{}{method, comp})
	fake.registerCompressorMutex.Unlock()
	if fake.RegisterCompressorStub != nil {
		fake.RegisterCompressorStub(method, comp)
	}
}

func (fake *FakeZip) RegisterCompressorCallCount() int {
	fake.registerCompressorMutex.RLock()
	defer fake.registerCompressorMutex.RUnlock()
	return len(fake.registerCompressorArgsForCall)
}

func (fake *FakeZip) RegisterCompressorArgsForCall(i int) (uint16, zip.Compressor) {
	fake.registerCompressorMutex.RLock()
	defer fake.registerCompressorMutex.RUnlock()
	return fake.registerCompressorArgsForCall[i].method, fake.registerCompressorArgsForCall[i].comp
}

func (fake *FakeZip) FileInfoHeader(fi os.FileInfo) (*zip.FileHeader, error) {
	fake.fileInfoHeaderMutex.Lock()
	ret, specificReturn := fake.fileInfoHeaderReturnsOnCall[len(fake.fileInfoHeaderArgsForCall)]
	fake.fileInfoHeaderArgsForCall = append(fake.fileInfoHeaderArgsForCall, struct {
		fi os.FileInfo
	}{fi})
	fake.recordInvocation("FileInfoHeader", []interface{}{fi})
	fake.fileInfoHeaderMutex.Unlock()
	if fake.FileInfoHeaderStub != nil {
		return fake.FileInfoHeaderStub(fi)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fileInfoHeaderReturns.result1, fake.fileInfoHeaderReturns.result2
}

func (fake *FakeZip) FileInfoHeaderCallCount() int {
	fake.fileInfoHeaderMutex.RLock()
	defer fake.fileInfoHeaderMutex.RUnlock()
	return len(fake.fileInfoHeaderArgsForCall)
}

func (fake *FakeZip) FileInfoHeaderArgsForCall(i int) os.FileInfo {
	fake.fileInfoHeaderMutex.RLock()
	defer fake.fileInfoHeaderMutex.RUnlock()
	return fake.fileInfoHeaderArgsForCall[i].fi
}

func (fake *FakeZip) FileInfoHeaderReturns(result1 *zip.FileHeader, result2 error) {
	fake.FileInfoHeaderStub = nil
	fake.fileInfoHeaderReturns = struct {
		result1 *zip.FileHeader
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) FileInfoHeaderReturnsOnCall(i int, result1 *zip.FileHeader, result2 error) {
	fake.FileInfoHeaderStub = nil
	if fake.fileInfoHeaderReturnsOnCall == nil {
		fake.fileInfoHeaderReturnsOnCall = make(map[int]struct {
			result1 *zip.FileHeader
			result2 error
		})
	}
	fake.fileInfoHeaderReturnsOnCall[i] = struct {
		result1 *zip.FileHeader
		result2 error
	}{result1, result2}
}

func (fake *FakeZip) NewWriter(w io.Writer) *zip.Writer {
	fake.newWriterMutex.Lock()
	ret, specificReturn := fake.newWriterReturnsOnCall[len(fake.newWriterArgsForCall)]
	fake.newWriterArgsForCall = append(fake.newWriterArgsForCall, struct {
		w io.Writer
	}{w})
	fake.recordInvocation("NewWriter", []interface{}{w})
	fake.newWriterMutex.Unlock()
	if fake.NewWriterStub != nil {
		return fake.NewWriterStub(w)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newWriterReturns.result1
}

func (fake *FakeZip) NewWriterCallCount() int {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return len(fake.newWriterArgsForCall)
}

func (fake *FakeZip) NewWriterArgsForCall(i int) io.Writer {
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	return fake.newWriterArgsForCall[i].w
}

func (fake *FakeZip) NewWriterReturns(result1 *zip.Writer) {
	fake.NewWriterStub = nil
	fake.newWriterReturns = struct {
		result1 *zip.Writer
	}{result1}
}

func (fake *FakeZip) NewWriterReturnsOnCall(i int, result1 *zip.Writer) {
	fake.NewWriterStub = nil
	if fake.newWriterReturnsOnCall == nil {
		fake.newWriterReturnsOnCall = make(map[int]struct {
			result1 *zip.Writer
		})
	}
	fake.newWriterReturnsOnCall[i] = struct {
		result1 *zip.Writer
	}{result1}
}

func (fake *FakeZip) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.openReaderMutex.RLock()
	defer fake.openReaderMutex.RUnlock()
	fake.newReaderMutex.RLock()
	defer fake.newReaderMutex.RUnlock()
	fake.registerDecompressorMutex.RLock()
	defer fake.registerDecompressorMutex.RUnlock()
	fake.registerCompressorMutex.RLock()
	defer fake.registerCompressorMutex.RUnlock()
	fake.fileInfoHeaderMutex.RLock()
	defer fake.fileInfoHeaderMutex.RUnlock()
	fake.newWriterMutex.RLock()
	defer fake.newWriterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeZip) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ goshim.Zip = new(FakeZip)
