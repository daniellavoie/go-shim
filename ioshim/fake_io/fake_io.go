// Code generated by counterfeiter. DO NOT EDIT.
package fake_io

import (
	"io"
	"sync"

	"github.com/daniellavoie/go-shim"
)

type FakeIo struct {
	WriteStringStub        func(w io.Writer, s string) (n int, err error)
	writeStringMutex       sync.RWMutex
	writeStringArgsForCall []struct {
		w io.Writer
		s string
	}
	writeStringReturns struct {
		result1 int
		result2 error
	}
	writeStringReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ReadAtLeastStub        func(r io.Reader, buf []byte, min int) (n int, err error)
	readAtLeastMutex       sync.RWMutex
	readAtLeastArgsForCall []struct {
		r   io.Reader
		buf []byte
		min int
	}
	readAtLeastReturns struct {
		result1 int
		result2 error
	}
	readAtLeastReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ReadFullStub        func(r io.Reader, buf []byte) (n int, err error)
	readFullMutex       sync.RWMutex
	readFullArgsForCall []struct {
		r   io.Reader
		buf []byte
	}
	readFullReturns struct {
		result1 int
		result2 error
	}
	readFullReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	CopyNStub        func(dst io.Writer, src io.Reader, n int64) (written int64, err error)
	copyNMutex       sync.RWMutex
	copyNArgsForCall []struct {
		dst io.Writer
		src io.Reader
		n   int64
	}
	copyNReturns struct {
		result1 int64
		result2 error
	}
	copyNReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	CopyStub        func(dst io.Writer, src io.Reader) (written int64, err error)
	copyMutex       sync.RWMutex
	copyArgsForCall []struct {
		dst io.Writer
		src io.Reader
	}
	copyReturns struct {
		result1 int64
		result2 error
	}
	copyReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	CopyBufferStub        func(dst io.Writer, src io.Reader, buf []byte) (written int64, err error)
	copyBufferMutex       sync.RWMutex
	copyBufferArgsForCall []struct {
		dst io.Writer
		src io.Reader
		buf []byte
	}
	copyBufferReturns struct {
		result1 int64
		result2 error
	}
	copyBufferReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	LimitReaderStub        func(r io.Reader, n int64) io.Reader
	limitReaderMutex       sync.RWMutex
	limitReaderArgsForCall []struct {
		r io.Reader
		n int64
	}
	limitReaderReturns struct {
		result1 io.Reader
	}
	limitReaderReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	NewSectionReaderStub        func(r io.ReaderAt, off int64, n int64) *io.SectionReader
	newSectionReaderMutex       sync.RWMutex
	newSectionReaderArgsForCall []struct {
		r   io.ReaderAt
		off int64
		n   int64
	}
	newSectionReaderReturns struct {
		result1 *io.SectionReader
	}
	newSectionReaderReturnsOnCall map[int]struct {
		result1 *io.SectionReader
	}
	TeeReaderStub        func(r io.Reader, w io.Writer) io.Reader
	teeReaderMutex       sync.RWMutex
	teeReaderArgsForCall []struct {
		r io.Reader
		w io.Writer
	}
	teeReaderReturns struct {
		result1 io.Reader
	}
	teeReaderReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	MultiReaderStub        func(readers ...io.Reader) io.Reader
	multiReaderMutex       sync.RWMutex
	multiReaderArgsForCall []struct {
		readers []io.Reader
	}
	multiReaderReturns struct {
		result1 io.Reader
	}
	multiReaderReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	MultiWriterStub        func(writers ...io.Writer) io.Writer
	multiWriterMutex       sync.RWMutex
	multiWriterArgsForCall []struct {
		writers []io.Writer
	}
	multiWriterReturns struct {
		result1 io.Writer
	}
	multiWriterReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	PipeStub        func() (*io.PipeReader, *io.PipeWriter)
	pipeMutex       sync.RWMutex
	pipeArgsForCall []struct{}
	pipeReturns     struct {
		result1 *io.PipeReader
		result2 *io.PipeWriter
	}
	pipeReturnsOnCall map[int]struct {
		result1 *io.PipeReader
		result2 *io.PipeWriter
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIo) WriteString(w io.Writer, s string) (n int, err error) {
	fake.writeStringMutex.Lock()
	ret, specificReturn := fake.writeStringReturnsOnCall[len(fake.writeStringArgsForCall)]
	fake.writeStringArgsForCall = append(fake.writeStringArgsForCall, struct {
		w io.Writer
		s string
	}{w, s})
	fake.recordInvocation("WriteString", []interface{}{w, s})
	fake.writeStringMutex.Unlock()
	if fake.WriteStringStub != nil {
		return fake.WriteStringStub(w, s)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.writeStringReturns.result1, fake.writeStringReturns.result2
}

func (fake *FakeIo) WriteStringCallCount() int {
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	return len(fake.writeStringArgsForCall)
}

func (fake *FakeIo) WriteStringArgsForCall(i int) (io.Writer, string) {
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	return fake.writeStringArgsForCall[i].w, fake.writeStringArgsForCall[i].s
}

func (fake *FakeIo) WriteStringReturns(result1 int, result2 error) {
	fake.WriteStringStub = nil
	fake.writeStringReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) WriteStringReturnsOnCall(i int, result1 int, result2 error) {
	fake.WriteStringStub = nil
	if fake.writeStringReturnsOnCall == nil {
		fake.writeStringReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeStringReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) ReadAtLeast(r io.Reader, buf []byte, min int) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.readAtLeastMutex.Lock()
	ret, specificReturn := fake.readAtLeastReturnsOnCall[len(fake.readAtLeastArgsForCall)]
	fake.readAtLeastArgsForCall = append(fake.readAtLeastArgsForCall, struct {
		r   io.Reader
		buf []byte
		min int
	}{r, bufCopy, min})
	fake.recordInvocation("ReadAtLeast", []interface{}{r, bufCopy, min})
	fake.readAtLeastMutex.Unlock()
	if fake.ReadAtLeastStub != nil {
		return fake.ReadAtLeastStub(r, buf, min)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readAtLeastReturns.result1, fake.readAtLeastReturns.result2
}

func (fake *FakeIo) ReadAtLeastCallCount() int {
	fake.readAtLeastMutex.RLock()
	defer fake.readAtLeastMutex.RUnlock()
	return len(fake.readAtLeastArgsForCall)
}

func (fake *FakeIo) ReadAtLeastArgsForCall(i int) (io.Reader, []byte, int) {
	fake.readAtLeastMutex.RLock()
	defer fake.readAtLeastMutex.RUnlock()
	return fake.readAtLeastArgsForCall[i].r, fake.readAtLeastArgsForCall[i].buf, fake.readAtLeastArgsForCall[i].min
}

func (fake *FakeIo) ReadAtLeastReturns(result1 int, result2 error) {
	fake.ReadAtLeastStub = nil
	fake.readAtLeastReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) ReadAtLeastReturnsOnCall(i int, result1 int, result2 error) {
	fake.ReadAtLeastStub = nil
	if fake.readAtLeastReturnsOnCall == nil {
		fake.readAtLeastReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readAtLeastReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) ReadFull(r io.Reader, buf []byte) (n int, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.readFullMutex.Lock()
	ret, specificReturn := fake.readFullReturnsOnCall[len(fake.readFullArgsForCall)]
	fake.readFullArgsForCall = append(fake.readFullArgsForCall, struct {
		r   io.Reader
		buf []byte
	}{r, bufCopy})
	fake.recordInvocation("ReadFull", []interface{}{r, bufCopy})
	fake.readFullMutex.Unlock()
	if fake.ReadFullStub != nil {
		return fake.ReadFullStub(r, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readFullReturns.result1, fake.readFullReturns.result2
}

func (fake *FakeIo) ReadFullCallCount() int {
	fake.readFullMutex.RLock()
	defer fake.readFullMutex.RUnlock()
	return len(fake.readFullArgsForCall)
}

func (fake *FakeIo) ReadFullArgsForCall(i int) (io.Reader, []byte) {
	fake.readFullMutex.RLock()
	defer fake.readFullMutex.RUnlock()
	return fake.readFullArgsForCall[i].r, fake.readFullArgsForCall[i].buf
}

func (fake *FakeIo) ReadFullReturns(result1 int, result2 error) {
	fake.ReadFullStub = nil
	fake.readFullReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) ReadFullReturnsOnCall(i int, result1 int, result2 error) {
	fake.ReadFullStub = nil
	if fake.readFullReturnsOnCall == nil {
		fake.readFullReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.readFullReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) CopyN(dst io.Writer, src io.Reader, n int64) (written int64, err error) {
	fake.copyNMutex.Lock()
	ret, specificReturn := fake.copyNReturnsOnCall[len(fake.copyNArgsForCall)]
	fake.copyNArgsForCall = append(fake.copyNArgsForCall, struct {
		dst io.Writer
		src io.Reader
		n   int64
	}{dst, src, n})
	fake.recordInvocation("CopyN", []interface{}{dst, src, n})
	fake.copyNMutex.Unlock()
	if fake.CopyNStub != nil {
		return fake.CopyNStub(dst, src, n)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.copyNReturns.result1, fake.copyNReturns.result2
}

func (fake *FakeIo) CopyNCallCount() int {
	fake.copyNMutex.RLock()
	defer fake.copyNMutex.RUnlock()
	return len(fake.copyNArgsForCall)
}

func (fake *FakeIo) CopyNArgsForCall(i int) (io.Writer, io.Reader, int64) {
	fake.copyNMutex.RLock()
	defer fake.copyNMutex.RUnlock()
	return fake.copyNArgsForCall[i].dst, fake.copyNArgsForCall[i].src, fake.copyNArgsForCall[i].n
}

func (fake *FakeIo) CopyNReturns(result1 int64, result2 error) {
	fake.CopyNStub = nil
	fake.copyNReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) CopyNReturnsOnCall(i int, result1 int64, result2 error) {
	fake.CopyNStub = nil
	if fake.copyNReturnsOnCall == nil {
		fake.copyNReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.copyNReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) Copy(dst io.Writer, src io.Reader) (written int64, err error) {
	fake.copyMutex.Lock()
	ret, specificReturn := fake.copyReturnsOnCall[len(fake.copyArgsForCall)]
	fake.copyArgsForCall = append(fake.copyArgsForCall, struct {
		dst io.Writer
		src io.Reader
	}{dst, src})
	fake.recordInvocation("Copy", []interface{}{dst, src})
	fake.copyMutex.Unlock()
	if fake.CopyStub != nil {
		return fake.CopyStub(dst, src)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.copyReturns.result1, fake.copyReturns.result2
}

func (fake *FakeIo) CopyCallCount() int {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	return len(fake.copyArgsForCall)
}

func (fake *FakeIo) CopyArgsForCall(i int) (io.Writer, io.Reader) {
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	return fake.copyArgsForCall[i].dst, fake.copyArgsForCall[i].src
}

func (fake *FakeIo) CopyReturns(result1 int64, result2 error) {
	fake.CopyStub = nil
	fake.copyReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) CopyReturnsOnCall(i int, result1 int64, result2 error) {
	fake.CopyStub = nil
	if fake.copyReturnsOnCall == nil {
		fake.copyReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.copyReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) CopyBuffer(dst io.Writer, src io.Reader, buf []byte) (written int64, err error) {
	var bufCopy []byte
	if buf != nil {
		bufCopy = make([]byte, len(buf))
		copy(bufCopy, buf)
	}
	fake.copyBufferMutex.Lock()
	ret, specificReturn := fake.copyBufferReturnsOnCall[len(fake.copyBufferArgsForCall)]
	fake.copyBufferArgsForCall = append(fake.copyBufferArgsForCall, struct {
		dst io.Writer
		src io.Reader
		buf []byte
	}{dst, src, bufCopy})
	fake.recordInvocation("CopyBuffer", []interface{}{dst, src, bufCopy})
	fake.copyBufferMutex.Unlock()
	if fake.CopyBufferStub != nil {
		return fake.CopyBufferStub(dst, src, buf)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.copyBufferReturns.result1, fake.copyBufferReturns.result2
}

func (fake *FakeIo) CopyBufferCallCount() int {
	fake.copyBufferMutex.RLock()
	defer fake.copyBufferMutex.RUnlock()
	return len(fake.copyBufferArgsForCall)
}

func (fake *FakeIo) CopyBufferArgsForCall(i int) (io.Writer, io.Reader, []byte) {
	fake.copyBufferMutex.RLock()
	defer fake.copyBufferMutex.RUnlock()
	return fake.copyBufferArgsForCall[i].dst, fake.copyBufferArgsForCall[i].src, fake.copyBufferArgsForCall[i].buf
}

func (fake *FakeIo) CopyBufferReturns(result1 int64, result2 error) {
	fake.CopyBufferStub = nil
	fake.copyBufferReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) CopyBufferReturnsOnCall(i int, result1 int64, result2 error) {
	fake.CopyBufferStub = nil
	if fake.copyBufferReturnsOnCall == nil {
		fake.copyBufferReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.copyBufferReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeIo) LimitReader(r io.Reader, n int64) io.Reader {
	fake.limitReaderMutex.Lock()
	ret, specificReturn := fake.limitReaderReturnsOnCall[len(fake.limitReaderArgsForCall)]
	fake.limitReaderArgsForCall = append(fake.limitReaderArgsForCall, struct {
		r io.Reader
		n int64
	}{r, n})
	fake.recordInvocation("LimitReader", []interface{}{r, n})
	fake.limitReaderMutex.Unlock()
	if fake.LimitReaderStub != nil {
		return fake.LimitReaderStub(r, n)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.limitReaderReturns.result1
}

func (fake *FakeIo) LimitReaderCallCount() int {
	fake.limitReaderMutex.RLock()
	defer fake.limitReaderMutex.RUnlock()
	return len(fake.limitReaderArgsForCall)
}

func (fake *FakeIo) LimitReaderArgsForCall(i int) (io.Reader, int64) {
	fake.limitReaderMutex.RLock()
	defer fake.limitReaderMutex.RUnlock()
	return fake.limitReaderArgsForCall[i].r, fake.limitReaderArgsForCall[i].n
}

func (fake *FakeIo) LimitReaderReturns(result1 io.Reader) {
	fake.LimitReaderStub = nil
	fake.limitReaderReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) LimitReaderReturnsOnCall(i int, result1 io.Reader) {
	fake.LimitReaderStub = nil
	if fake.limitReaderReturnsOnCall == nil {
		fake.limitReaderReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.limitReaderReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) NewSectionReader(r io.ReaderAt, off int64, n int64) *io.SectionReader {
	fake.newSectionReaderMutex.Lock()
	ret, specificReturn := fake.newSectionReaderReturnsOnCall[len(fake.newSectionReaderArgsForCall)]
	fake.newSectionReaderArgsForCall = append(fake.newSectionReaderArgsForCall, struct {
		r   io.ReaderAt
		off int64
		n   int64
	}{r, off, n})
	fake.recordInvocation("NewSectionReader", []interface{}{r, off, n})
	fake.newSectionReaderMutex.Unlock()
	if fake.NewSectionReaderStub != nil {
		return fake.NewSectionReaderStub(r, off, n)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newSectionReaderReturns.result1
}

func (fake *FakeIo) NewSectionReaderCallCount() int {
	fake.newSectionReaderMutex.RLock()
	defer fake.newSectionReaderMutex.RUnlock()
	return len(fake.newSectionReaderArgsForCall)
}

func (fake *FakeIo) NewSectionReaderArgsForCall(i int) (io.ReaderAt, int64, int64) {
	fake.newSectionReaderMutex.RLock()
	defer fake.newSectionReaderMutex.RUnlock()
	return fake.newSectionReaderArgsForCall[i].r, fake.newSectionReaderArgsForCall[i].off, fake.newSectionReaderArgsForCall[i].n
}

func (fake *FakeIo) NewSectionReaderReturns(result1 *io.SectionReader) {
	fake.NewSectionReaderStub = nil
	fake.newSectionReaderReturns = struct {
		result1 *io.SectionReader
	}{result1}
}

func (fake *FakeIo) NewSectionReaderReturnsOnCall(i int, result1 *io.SectionReader) {
	fake.NewSectionReaderStub = nil
	if fake.newSectionReaderReturnsOnCall == nil {
		fake.newSectionReaderReturnsOnCall = make(map[int]struct {
			result1 *io.SectionReader
		})
	}
	fake.newSectionReaderReturnsOnCall[i] = struct {
		result1 *io.SectionReader
	}{result1}
}

func (fake *FakeIo) TeeReader(r io.Reader, w io.Writer) io.Reader {
	fake.teeReaderMutex.Lock()
	ret, specificReturn := fake.teeReaderReturnsOnCall[len(fake.teeReaderArgsForCall)]
	fake.teeReaderArgsForCall = append(fake.teeReaderArgsForCall, struct {
		r io.Reader
		w io.Writer
	}{r, w})
	fake.recordInvocation("TeeReader", []interface{}{r, w})
	fake.teeReaderMutex.Unlock()
	if fake.TeeReaderStub != nil {
		return fake.TeeReaderStub(r, w)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teeReaderReturns.result1
}

func (fake *FakeIo) TeeReaderCallCount() int {
	fake.teeReaderMutex.RLock()
	defer fake.teeReaderMutex.RUnlock()
	return len(fake.teeReaderArgsForCall)
}

func (fake *FakeIo) TeeReaderArgsForCall(i int) (io.Reader, io.Writer) {
	fake.teeReaderMutex.RLock()
	defer fake.teeReaderMutex.RUnlock()
	return fake.teeReaderArgsForCall[i].r, fake.teeReaderArgsForCall[i].w
}

func (fake *FakeIo) TeeReaderReturns(result1 io.Reader) {
	fake.TeeReaderStub = nil
	fake.teeReaderReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) TeeReaderReturnsOnCall(i int, result1 io.Reader) {
	fake.TeeReaderStub = nil
	if fake.teeReaderReturnsOnCall == nil {
		fake.teeReaderReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.teeReaderReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) MultiReader(readers ...io.Reader) io.Reader {
	fake.multiReaderMutex.Lock()
	ret, specificReturn := fake.multiReaderReturnsOnCall[len(fake.multiReaderArgsForCall)]
	fake.multiReaderArgsForCall = append(fake.multiReaderArgsForCall, struct {
		readers []io.Reader
	}{readers})
	fake.recordInvocation("MultiReader", []interface{}{readers})
	fake.multiReaderMutex.Unlock()
	if fake.MultiReaderStub != nil {
		return fake.MultiReaderStub(readers...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.multiReaderReturns.result1
}

func (fake *FakeIo) MultiReaderCallCount() int {
	fake.multiReaderMutex.RLock()
	defer fake.multiReaderMutex.RUnlock()
	return len(fake.multiReaderArgsForCall)
}

func (fake *FakeIo) MultiReaderArgsForCall(i int) []io.Reader {
	fake.multiReaderMutex.RLock()
	defer fake.multiReaderMutex.RUnlock()
	return fake.multiReaderArgsForCall[i].readers
}

func (fake *FakeIo) MultiReaderReturns(result1 io.Reader) {
	fake.MultiReaderStub = nil
	fake.multiReaderReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) MultiReaderReturnsOnCall(i int, result1 io.Reader) {
	fake.MultiReaderStub = nil
	if fake.multiReaderReturnsOnCall == nil {
		fake.multiReaderReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.multiReaderReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeIo) MultiWriter(writers ...io.Writer) io.Writer {
	fake.multiWriterMutex.Lock()
	ret, specificReturn := fake.multiWriterReturnsOnCall[len(fake.multiWriterArgsForCall)]
	fake.multiWriterArgsForCall = append(fake.multiWriterArgsForCall, struct {
		writers []io.Writer
	}{writers})
	fake.recordInvocation("MultiWriter", []interface{}{writers})
	fake.multiWriterMutex.Unlock()
	if fake.MultiWriterStub != nil {
		return fake.MultiWriterStub(writers...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.multiWriterReturns.result1
}

func (fake *FakeIo) MultiWriterCallCount() int {
	fake.multiWriterMutex.RLock()
	defer fake.multiWriterMutex.RUnlock()
	return len(fake.multiWriterArgsForCall)
}

func (fake *FakeIo) MultiWriterArgsForCall(i int) []io.Writer {
	fake.multiWriterMutex.RLock()
	defer fake.multiWriterMutex.RUnlock()
	return fake.multiWriterArgsForCall[i].writers
}

func (fake *FakeIo) MultiWriterReturns(result1 io.Writer) {
	fake.MultiWriterStub = nil
	fake.multiWriterReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeIo) MultiWriterReturnsOnCall(i int, result1 io.Writer) {
	fake.MultiWriterStub = nil
	if fake.multiWriterReturnsOnCall == nil {
		fake.multiWriterReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.multiWriterReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeIo) Pipe() (*io.PipeReader, *io.PipeWriter) {
	fake.pipeMutex.Lock()
	ret, specificReturn := fake.pipeReturnsOnCall[len(fake.pipeArgsForCall)]
	fake.pipeArgsForCall = append(fake.pipeArgsForCall, struct{}{})
	fake.recordInvocation("Pipe", []interface{}{})
	fake.pipeMutex.Unlock()
	if fake.PipeStub != nil {
		return fake.PipeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pipeReturns.result1, fake.pipeReturns.result2
}

func (fake *FakeIo) PipeCallCount() int {
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	return len(fake.pipeArgsForCall)
}

func (fake *FakeIo) PipeReturns(result1 *io.PipeReader, result2 *io.PipeWriter) {
	fake.PipeStub = nil
	fake.pipeReturns = struct {
		result1 *io.PipeReader
		result2 *io.PipeWriter
	}{result1, result2}
}

func (fake *FakeIo) PipeReturnsOnCall(i int, result1 *io.PipeReader, result2 *io.PipeWriter) {
	fake.PipeStub = nil
	if fake.pipeReturnsOnCall == nil {
		fake.pipeReturnsOnCall = make(map[int]struct {
			result1 *io.PipeReader
			result2 *io.PipeWriter
		})
	}
	fake.pipeReturnsOnCall[i] = struct {
		result1 *io.PipeReader
		result2 *io.PipeWriter
	}{result1, result2}
}

func (fake *FakeIo) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.writeStringMutex.RLock()
	defer fake.writeStringMutex.RUnlock()
	fake.readAtLeastMutex.RLock()
	defer fake.readAtLeastMutex.RUnlock()
	fake.readFullMutex.RLock()
	defer fake.readFullMutex.RUnlock()
	fake.copyNMutex.RLock()
	defer fake.copyNMutex.RUnlock()
	fake.copyMutex.RLock()
	defer fake.copyMutex.RUnlock()
	fake.copyBufferMutex.RLock()
	defer fake.copyBufferMutex.RUnlock()
	fake.limitReaderMutex.RLock()
	defer fake.limitReaderMutex.RUnlock()
	fake.newSectionReaderMutex.RLock()
	defer fake.newSectionReaderMutex.RUnlock()
	fake.teeReaderMutex.RLock()
	defer fake.teeReaderMutex.RUnlock()
	fake.multiReaderMutex.RLock()
	defer fake.multiReaderMutex.RUnlock()
	fake.multiWriterMutex.RLock()
	defer fake.multiWriterMutex.RUnlock()
	fake.pipeMutex.RLock()
	defer fake.pipeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIo) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ goshim.Io = new(FakeIo)
